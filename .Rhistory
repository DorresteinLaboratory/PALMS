j <- as.numeric(selsumm[i,1])
d1 <- data.frame(x=1:nrow(opt2), int=as.vector(as.matrix(log10(opt2[,j]))), labels=mn)
#d1 <- data.frame(x=1:18, int=as.vector(as.matrix((tab[565,-c(1:5)]))), labels=mn[-c(1:5)])
d1 <- d1[vec,]
#d1 <- d1[nrow(d1):1,]
lb <- table(d1$labels)
# assumes same number of technical replicates
x <- rep(1:length(lb), each=lb[1])
par(las=2)
ym <- tapply(d1$int, d1$labels, mean)[as.character(unique(d1$labels))]
plot(1:length(lb), ym, pch=19,  ylab="Log intensity", xlab="", xaxt="n")
sd <- tapply(d1$int, d1$labels, sd)[as.character(unique(d1$labels))]
segments(1:length(lb), ym-sd, 1:length(lb), ym+sd)
epsilon = 0.02
segments(1:length(lb)-epsilon,ym-sd,1:length(lb)+epsilon,ym-sd)
segments(1:length(lb)-epsilon,ym+sd,1:length(lb)+epsilon,ym+sd)
axis(1, at=1:length(lb), labels=as.character(unique(d1$labels)), cex=0.8)
# allow just concentrations with 3 replicates to model
for(k in 1:nrow(d1)) if( d1[k,2]==-Inf) d1[d1[,3]==d1[k,3],2] <- -Inf
y <- d1$int
x <- x[y!=-Inf]
y <- y[y!=-Inf]
l1 <- lm(y~x)
s1 <- summary(lm(y~c(x-x[1])))
ym <- ym[ym!=-Inf]
#l2 <- lm(ym~log10(rev(yl[1:length(unique(x))])))
#s2 <- summary(l2)
# every thing should be in the correct order for this step
l3 <- lm(log10(yl[unique(x)]) ~ ym)
s3 <- summary(l3)
#modList <- c(modList, l3)
syx <- steyx(y, x)
ylod <- 3*syx+s1$coefficients[1,1]
xlod <- 3*syx/s1$coefficients[2,1]
# assumes that difference in the log scale is the same as between each two consecutive points,
# and there is no missing points
lod <- 10^(log10(yl[unique(x)])[1]+xlod )
plab <- which(sub(".+(e.+$)", "\\1", as.character(rev(yl)))==sub(".+(e.+$)", "\\1", as.character(lod)))
lab <- gsub("\\d", "", as.character(unique(d1$labels))[plab])
lodl <- round(as.numeric(sub("e-.+$",  "", lod)), 3)
points(xlod+x[1], ylod, pch=20,col=2)
#text(xlod+x[1], ylod, paste0("LoD = b+3sd = ", lodl, lab), pos=4,col=2)
#text(xlod+x[1], ylod, paste0("LoD = b+3sd = ", lodl, lab), pos=4,col=2)
legend("topleft",  paste0("LoD = b+3sd = ", lod), bty="n", text.col=2)
if(selsumm[i,6]!="") {
title(paste(selsumm[i,2], "\n",  selsumm[i,6],
"\n", "R2", round(s1$adj.r.squared, 3), "p-value", format(s1$coefficients[2,4], scientific=TRUE, digits=3) ))
} else {
title(paste(selsumm[i,2], "\n",
"R2", round(s1$adj.r.squared, 3), "p-value", format(s1$coefficients[2,4], scientific=TRUE, digits=3) ))
}
abline(l1)
#summ <- rbind(summ, c(selsumm[i,], syx, lod))
summ <- rbind(summ, c(selsumm[i,c(1,2,6)], s3$coefficients[1,1], s3$coefficients[2,1], s3$r.squared,  s1$coefficients[2,4], lod,
10^min(ym), 10^max(ym)))
}
cnames <- c("Feat_pos", "Mz_rt", "Name", "Intercept", "Slope", "R2", "p-value", "LoD", "MinInt", "MaxInt")
summ <- matrix(summ[-1,], ncol=10)
selsumm
opt2 <- t(optmp[,-1])
colnames(opt2) <- sub("-", "\\.", optmp[,1])
conc <- read.csv(inFile11$datapath)
runApp()
runApp()
runApp()
runApp()
opt2 <- t(optmp[,-1])
colnames(opt2) <- sub("-", "\\.", optmp[,1])
conc <- read.csv(inFile11$datapath)
conc <- read.csv("~/Desktop/rephotos/6TM_QE_BK_10K_conc_table_corrected.csv")
conc
opt2 <- data.frame(SampleID=rownames(opt2)[-nrow(opt2)], conc, opt2[-nrow(opt2),])
rownames(opt2) <- NULL
opt2
mexp <- data.frame(suffix=c("pM", "nM", "uM"), fac=c(10^-12, 10^-9, 10^-6))
exp <- read.csv(inFile$datapath)
exp <- read.csv("~/Desktop/rephotos/QQQ_6TM_NoBK_naming_file.csv")
exp
exp2 <- as.matrix(exp[, 1:2])
runApp()
opt23
opt2
exp <- read.csv(inFile$datapath)
exp <- read.csv("~/Desktop/rephotos/QQQ_6TM_NoBK_naming_file_corrected.csv")
exp
exp2 <- as.matrix(exp[, 1:2])
mn <- sub("_", "", opt2[,2])
mstep1 <- as.numeric(gsub("\\D", '', mn))
mstep2 <- mexp[sapply(gsub("\\d", '', mn), function(x) which(mexp[,1]==x)),2]
vec <- order(mstep1 * mstep2)
summ <- rep("", 5)
for(j in 3:ncol(opt2)) {
d1 <- data.frame(x=1:nrow(opt2), int=as.vector(as.matrix(log10(as.numeric(opt2[,j])))), labels=mn)
d1 <- d1[vec,]
x <- 1:length(unique(d1$labels))
y <- tapply(d1$int, d1$labels, mean)[as.character(unique(d1$labels))]
x <- x[y!=-Inf]
y <- y[y!=-Inf]
if(length(y)>1) {
s1 <- summary((lm(y~x)))
# added one regression parameter, the slope at the end
summ <- rbind(summ, c(j, colnames(opt2)[j] ,  round(s1$adj.r.squared, 3), s1$coefficients[2,4], s1$
coefficients[,1][2]) )
} else{
summ <- rbind(summ, c(j, colnames(opt2)[j],  0, 0, 0))
}
}
#trresults_all <- summ
summ <- summ[-1,][!is.nan(as.numeric(summ[-1,3])),]
selsumm <- summ[as.numeric(as.matrix(summ[,3]))>0,]
name2fet <- function(fet) {
strf <- strsplit(fet, "\\.")
mz <- paste(strf[[1]][1:2], collapse = ".")
mz <- as.numeric(sub("^X", "", mz))
rt <- as.numeric(paste(strf[[1]][3], collapse = "."))
c(mz, rt)
}
fetm <- as.vector(as.matrix(selsumm[,2]))
fetm <- do.call(rbind, lapply(fetm, name2fet))
m.list.mz.rt_opt <- apply(exp2, 1,  function(x) which((fetm[,1] > x[1]-0.05) & (fetm[,1] < x[1]+0.05)))
selsumm <- cbind(selsumm, "")
for(i in 1:length(m.list.mz.rt_opt)) if(length(m.list.mz.rt_opt[[i]])) selsumm[m.list.mz.rt_opt[[i]], ncol(selsumm)] <- as.character(exp[i,3])
m.list.mz.rt_opt
head(fetm)
exp2
selsumm
op2
opt2
fetm
fetm <- fetm[, c(2:1)]
fetm
m.list.mz.rt_opt <- apply(exp2, 1,  function(x) which((fetm[,1] > x[1]-0.05) & (fetm[,1] < x[1]+0.05)))
m.list.mz.rt_opt
selsumm <- cbind(selsumm, "")
for(i in 1:length(m.list.mz.rt_opt)) if(length(m.list.mz.rt_opt[[i]])) selsumm[m.list.mz.rt_opt[[i]], ncol(selsumm)] <- as.character(exp[i,3])
runApp()
fetm
runApp()
selsumm
m.list.mz.rt_opt <- apply(exp2, 1,  function(x) which((fetm[,1] > x[1]-0.05) & (fetm[,1] < x[1]+0.05)))
m.list.mz.rt_opt
runApp()
optmp <- read.delim(inFile$datapath)
optmp <- read.delim("~/Desktop/rephotos/0672809f991e4130825684f04fea4437.table")
opt2 <- t(optmp[,-1])
colnames(opt2) <- sub("-", "\\.", optmp[,1])
conc <- read.csv(inFile11$datapath)
conc <- read.csv("~/Desktop/rephotos/QQQ_6TM_NoBK_naming_file_corrected.csv")
conc <- read.csv("~/Desktop/rephotos/6TM_QE_BK_10K_conc_table_corrected.csv")
conc
opt2 <- data.frame(SampleID=rownames(opt2)[-nrow(opt2)], conc, opt2[-nrow(opt2),])
rownames(opt2) <- NULL
mexp <- data.frame(suffix=c("pM", "nM", "uM"), fac=c(10^-12, 10^-9, 10^-6))
exp <- read.csv(inFile$datapath)
exp <- read.csv("~/Desktop/rephotos/QQQ_6TM_NoBK_naming_file_corrected.csv")
exp
exp2 <- as.matrix(exp[, 1:2])
mn <- sub("_", "", opt2[,2])
mstep1 <- as.numeric(gsub("\\D", '', mn))
mstep2 <- mexp[sapply(gsub("\\d", '', mn), function(x) which(mexp[,1]==x)),2]
vec <- order(mstep1 * mstep2)
summ <- rep("", 5)
for(j in 3:ncol(opt2)) {
d1 <- data.frame(x=1:nrow(opt2), int=as.vector(as.matrix(log10(as.numeric(opt2[,j])))), labels=mn)
d1 <- d1[vec,]
x <- 1:length(unique(d1$labels))
y <- tapply(d1$int, d1$labels, mean)[as.character(unique(d1$labels))]
x <- x[y!=-Inf]
y <- y[y!=-Inf]
if(length(y)>1) {
s1 <- summary((lm(y~x)))
# added one regression parameter, the slope at the end
summ <- rbind(summ, c(j, colnames(opt2)[j] ,  round(s1$adj.r.squared, 3), s1$coefficients[2,4], s1$
coefficients[,1][2]) )
} else{
summ <- rbind(summ, c(j, colnames(opt2)[j],  0, 0, 0))
}
}
#trresults_all <- summ
summ <- summ[-1,][!is.nan(as.numeric(summ[-1,3])),]
selsumm <- summ[as.numeric(as.matrix(summ[,3]))>0,]
name2fet <- function(fet) {
strf <- strsplit(fet, "\\.")
mz <- paste(strf[[1]][1:2], collapse = ".")
mz <- as.numeric(sub("^X", "", mz))
rt <- as.numeric(paste(strf[[1]][3], collapse = "."))
c(mz, rt)
}
fetm <- as.vector(as.matrix(selsumm[,2]))
fetm <- do.call(rbind, lapply(fetm, name2fet))
fetm
fetm <- fetm[, c(2:1)]
m.list.mz.rt_opt <- apply(exp2, 1,  function(x) which((fetm[,1] > x[1]-0.05) & (fetm[,1] < x[1]+0.05)))
if(length(m.list.mz.rt_opt)) {
selsumm <- cbind(selsumm, "")
for(i in 1:length(m.list.mz.rt_opt)) if(length(m.list.mz.rt_opt[[i]])) selsumm[m.list.mz.rt_opt[[i]], ncol(selsumm)] <- as.character(exp[i,3])
# selsumm[,2] <- sub(" \\[.+\\]", "", selsumm[,2])
selsumm[,2] <- apply(fetm, 1, function(x) paste(x, collapse = "_"))
} else {
selsumm <- cbind(selsumm, "")
selsumm[,2] <- apply(fetm, 1, function(x) paste(x, collapse = "_"))
}
selsumm
steyx <- function(y, x) sqrt ( (1/(length(y)-2)) * ( sum((y-mean(y))^2) - (sum((x-mean(x))*(y-mean(y)))^2)/sum((x-mean(x))^2) ) )
#yl <- c(10/10^6, 1/10^6, 100/10^9, 10/10^9, 1/10^9, 100/10^12, 10/10^12)
yl <- tapply((mstep1*mstep2)[vec], mn[vec], function(x) x[1])
yl <- yl[order(yl)]
summ <- rep("", 10)
opar <- par()
for(i in 1:nrow(selsumm)) {
if(as.numeric(selsumm[i,5])<0) next
# This line controls whether to plot lines that are flat
# as we should expect inclined lines
if(round(as.numeric(selsumm[i,5]))==0) next
# filter by R2
if(as.numeric(selsumm[i,3])<0.9) next
j <- as.numeric(selsumm[i,1])
d1 <- data.frame(x=1:nrow(opt2), int=as.vector(as.matrix(log10(opt2[,j]))), labels=mn)
#d1 <- data.frame(x=1:18, int=as.vector(as.matrix((tab[565,-c(1:5)]))), labels=mn[-c(1:5)])
d1 <- d1[vec,]
#d1 <- d1[nrow(d1):1,]
lb <- table(d1$labels)
# assumes same number of technical replicates
x <- rep(1:length(lb), each=lb[1])
par(las=2)
ym <- tapply(d1$int, d1$labels, mean)[as.character(unique(d1$labels))]
plot(1:length(lb), ym, pch=19,  ylab="Log intensity", xlab="", xaxt="n")
sd <- tapply(d1$int, d1$labels, sd)[as.character(unique(d1$labels))]
segments(1:length(lb), ym-sd, 1:length(lb), ym+sd)
epsilon = 0.02
segments(1:length(lb)-epsilon,ym-sd,1:length(lb)+epsilon,ym-sd)
segments(1:length(lb)-epsilon,ym+sd,1:length(lb)+epsilon,ym+sd)
axis(1, at=1:length(lb), labels=as.character(unique(d1$labels)), cex=0.8)
# allow just concentrations with 3 replicates to model
for(k in 1:nrow(d1)) if( d1[k,2]==-Inf) d1[d1[,3]==d1[k,3],2] <- -Inf
y <- d1$int
x <- x[y!=-Inf]
y <- y[y!=-Inf]
l1 <- lm(y~x)
s1 <- summary(lm(y~c(x-x[1])))
ym <- ym[ym!=-Inf]
#l2 <- lm(ym~log10(rev(yl[1:length(unique(x))])))
#s2 <- summary(l2)
# every thing should be in the correct order for this step
l3 <- lm(log10(yl[unique(x)]) ~ ym)
s3 <- summary(l3)
#modList <- c(modList, l3)
syx <- steyx(y, x)
ylod <- 3*syx+s1$coefficients[1,1]
xlod <- 3*syx/s1$coefficients[2,1]
# assumes that difference in the log scale is the same as between each two consecutive points,
# and there is no missing points
lod <- 10^(log10(yl[unique(x)])[1]+xlod )
plab <- which(sub(".+(e.+$)", "\\1", as.character(rev(yl)))==sub(".+(e.+$)", "\\1", as.character(lod)))
lab <- gsub("\\d", "", as.character(unique(d1$labels))[plab])
lodl <- round(as.numeric(sub("e-.+$",  "", lod)), 3)
points(xlod+x[1], ylod, pch=20,col=2)
#text(xlod+x[1], ylod, paste0("LoD = b+3sd = ", lodl, lab), pos=4,col=2)
#text(xlod+x[1], ylod, paste0("LoD = b+3sd = ", lodl, lab), pos=4,col=2)
legend("topleft",  paste0("LoD = b+3sd = ", lod), bty="n", text.col=2)
if(selsumm[i,6]!="") {
title(paste(selsumm[i,2], "\n",  selsumm[i,6],
"\n", "R2", round(s1$adj.r.squared, 3), "p-value", format(s1$coefficients[2,4], scientific=TRUE, digits=3) ))
} else {
title(paste(selsumm[i,2], "\n",
"R2", round(s1$adj.r.squared, 3), "p-value", format(s1$coefficients[2,4], scientific=TRUE, digits=3) ))
}
abline(l1)
#summ <- rbind(summ, c(selsumm[i,], syx, lod))
summ <- rbind(summ, c(selsumm[i,c(1,2,6)], s3$coefficients[1,1], s3$coefficients[2,1], s3$r.squared,  s1$coefficients[2,4], lod,
10^min(ym), 10^max(ym)))
}
selsumm
cnames <- c("Feat_pos", "Mz_rt", "Name", "Intercept", "Slope", "R2", "p-value", "LoD", "MinInt", "MaxInt")
summ <- matrix(summ[-1,], ncol=10)
colnames(summ) <- cnames
summ
shiny::runApp()
pdf("calibration_curve.pdf")
summ <- rep("", 10)
opar <- par()
for(i in 1:nrow(selsumm)) {
if(as.numeric(selsumm[i,5])<0) next
# This line controls whether to plot lines that are flat
# as we should expect inclined lines
if(round(as.numeric(selsumm[i,5]))==0) next
# filter by R2
if(as.numeric(selsumm[i,3])<0.9) next
j <- as.numeric(selsumm[i,1])
d1 <- data.frame(x=1:nrow(opt2), int=as.vector(as.matrix(log10(opt2[,j]))), labels=mn)
#d1 <- data.frame(x=1:18, int=as.vector(as.matrix((tab[565,-c(1:5)]))), labels=mn[-c(1:5)])
d1 <- d1[vec,]
#d1 <- d1[nrow(d1):1,]
lb <- table(d1$labels)
# assumes same number of technical replicates
x <- rep(1:length(lb), each=lb[1])
par(las=2)
ym <- tapply(d1$int, d1$labels, mean)[as.character(unique(d1$labels))]
plot(1:length(lb), ym, pch=19,  ylab="Log intensity", xlab="", xaxt="n")
sd <- tapply(d1$int, d1$labels, sd)[as.character(unique(d1$labels))]
segments(1:length(lb), ym-sd, 1:length(lb), ym+sd)
epsilon = 0.02
segments(1:length(lb)-epsilon,ym-sd,1:length(lb)+epsilon,ym-sd)
segments(1:length(lb)-epsilon,ym+sd,1:length(lb)+epsilon,ym+sd)
axis(1, at=1:length(lb), labels=as.character(unique(d1$labels)), cex=0.8)
# allow just concentrations with 3 replicates to model
for(k in 1:nrow(d1)) if( d1[k,2]==-Inf) d1[d1[,3]==d1[k,3],2] <- -Inf
y <- d1$int
x <- x[y!=-Inf]
y <- y[y!=-Inf]
l1 <- lm(y~x)
s1 <- summary(lm(y~c(x-x[1])))
ym <- ym[ym!=-Inf]
#l2 <- lm(ym~log10(rev(yl[1:length(unique(x))])))
#s2 <- summary(l2)
# every thing should be in the correct order for this step
l3 <- lm(log10(yl[unique(x)]) ~ ym)
s3 <- summary(l3)
#modList <- c(modList, l3)
syx <- steyx(y, x)
ylod <- 3*syx+s1$coefficients[1,1]
xlod <- 3*syx/s1$coefficients[2,1]
# assumes that difference in the log scale is the same as between each two consecutive points,
# and there is no missing points
lod <- 10^(log10(yl[unique(x)])[1]+xlod )
plab <- which(sub(".+(e.+$)", "\\1", as.character(rev(yl)))==sub(".+(e.+$)", "\\1", as.character(lod)))
lab <- gsub("\\d", "", as.character(unique(d1$labels))[plab])
lodl <- round(as.numeric(sub("e-.+$",  "", lod)), 3)
points(xlod+x[1], ylod, pch=20,col=2)
#text(xlod+x[1], ylod, paste0("LoD = b+3sd = ", lodl, lab), pos=4,col=2)
#text(xlod+x[1], ylod, paste0("LoD = b+3sd = ", lodl, lab), pos=4,col=2)
legend("topleft",  paste0("LoD = b+3sd = ", lod), bty="n", text.col=2)
if(selsumm[i,6]!="") {
title(paste(selsumm[i,2], "\n",  selsumm[i,6],
"\n", "R2", round(s1$adj.r.squared, 3), "p-value", format(s1$coefficients[2,4], scientific=TRUE, digits=3) ))
} else {
title(paste(selsumm[i,2], "\n",
"R2", round(s1$adj.r.squared, 3), "p-value", format(s1$coefficients[2,4], scientific=TRUE, digits=3) ))
}
abline(l1)
#summ <- rbind(summ, c(selsumm[i,], syx, lod))
summ <- rbind(summ, c(selsumm[i,c(1,2,6)], s3$coefficients[1,1], s3$coefficients[2,1], s3$r.squared,  s1$coefficients[2,4], lod,
10^min(ym), 10^max(ym)))
}
dev.off()
cnames <- c("Feat_pos", "Mz_rt", "Name", "Intercept", "Slope", "R2", "p-value", "LoD", "MinInt", "MaxInt")
summ <- matrix(summ[-1,], ncol=10)
colnames(summ) <- cnames
write.csv(summ, "calibration_curve_table.csv", row.names = FALSE)
runApp()
length(m.list.mz.rt_opt)
head(m.list.mz.rt_opt)
selsumm
summ
runApp()
shiny::runApp()
optmp <- read.delim(inFile$datapath)
optmp <- read.delim("~/Desktop/recurvesfromgnps/9024b2dea47a454899520f5dfdf89a74.table")
optmp
optmp2 <- read.delim("~/Desktop/rephotos/0672809f991e4130825684f04fea4437.table")
optmp
optmp2
opt2 <- t(optmp[,-1])
colnames(opt2) <- sub("-", "\\.", optmp[,1])
conc <- read.csv(inFile11$datapath)
conc <- read.csv("~/Desktop/recurvesfromgnps/43ST_QQQ_BK_conc_table_corrected.csv")
conc
opt2 <- data.frame(SampleID=rownames(opt2)[-nrow(opt2)], conc, opt2[-nrow(opt2),])
opt2 <- data.frame(SampleID=rownames(opt2), conc, opt2[-nrow(opt2),])
conc
opt2 <- data.frame(SampleID=rownames(opt2), conc, opt2)
opt2
runApp()
shiny::runApp()
opt2 <- fread(inFile$datapath, header = TRUE, sep=",")
library("data.table")
opt2 <- fread("../../features_quantification_matrix.csv", header = TRUE, sep=",")
colnames(opt2) <- gsub(" ", "\\.", colnames(opt2) )
mexp <- data.frame(suffix=c("pM", "nM", "uM"), fac=c(10^-12, 10^-9, 10^-6))
exp <- read.csv(inFile$datapath)
exp <- read.csv("../../QQQ_43ST_NoBK_naming_file.csv")
exp2 <- as.matrix(exp[, 1:2])
exp2
mn <- sub("_", "", opt2[,2])
mstep1 <- as.numeric(gsub("\\D", '', mn))
mstep2 <- mexp[sapply(gsub("\\d", '', mn), function(x) which(mexp[,1]==x)),2]
mn
dim(opt2)
opt2[1:5,1:5]
opt2 <- as.data.frame(opt2)
opt2[1:5,1:5]
runApp()
shiny::runApp()
optmp <- read.delim(inFile$datapath)
optmp <- read.delim("~/Desktop/d8daaaa7e0dc4b77b81ad33fc003effe.table")
opt2 <- t(optmp[,-1])
colnames(opt2) <- sub("-", "\\.", optmp[,1])
conc <- read.csv("~/Desktop/Conc_correct_order.csv")
conc
opt2[1:5,1:5]
rownames(opt2)[nrow(opt2)]=="X"
if(rownames(opt2)[nrow(opt2)]=="X"){
opt2 <- data.frame(SampleID=rownames(opt2)[-nrow(opt2)], conc, opt2[-nrow(opt2),])
} else {
opt2 <- data.frame(SampleID=rownames(opt2), conc, opt2)
}
rownames(opt2) <- NULL
opt2[1:5,1:5]
mexp <- data.frame(suffix=c("pM", "nM", "uM"), fac=c(10^-12, 10^-9, 10^-6))
mn <- sub("_", "", opt2[,2])
mstep1 <- as.numeric(gsub("\\D", '', mn))
mstep2 <- mexp[sapply(gsub("\\d", '', mn), function(x) which(mexp[,1]==x)),2]
vec <- order(mstep1 * mstep2)
summ <- rep("", 5)
for(j in 3:ncol(opt2)) {
d1 <- data.frame(x=1:nrow(opt2), int=as.vector(as.matrix(log10(as.numeric(opt2[,j])))), labels=mn)
d1 <- d1[vec,]
x <- 1:length(unique(d1$labels))
y <- tapply(d1$int, d1$labels, mean)[as.character(unique(d1$labels))]
x <- x[y!=-Inf]
y <- y[y!=-Inf]
if(length(y)>1) {
s1 <- summary((lm(y~x)))
# added one regression parameter, the slope at the end
summ <- rbind(summ, c(j, colnames(opt2)[j] ,  round(s1$adj.r.squared, 3), s1$coefficients[2,4], s1$
coefficients[,1][2]) )
} else{
summ <- rbind(summ, c(j, colnames(opt2)[j],  0, 0, 0))
}
}
summ <- summ[-1,][!is.nan(as.numeric(summ[-1,3])),]
selsumm <- summ[as.numeric(as.matrix(summ[,3]))>0,]
name2fet <- function(fet) {
strf <- strsplit(fet, "\\.")
mz <- paste(strf[[1]][1:2], collapse = ".")
mz <- as.numeric(sub("^X", "", mz))
rt <- as.numeric(paste(strf[[1]][3], collapse = "."))
c(mz, rt)
}
dim(summ)
dim(selsumm)
head(summ)
conc
opt2[1:5,1:5]
opt2[,1:2]
as.numeric(as.matrix(summ[,3]))
j <- 3
d1 <- data.frame(x=1:nrow(opt2), int=as.vector(as.matrix(log10(as.numeric(opt2[,j])))), labels=mn)
d1 <- d1[vec,]
x <- 1:length(unique(d1$labels))
y <- tapply(d1$int, d1$labels, mean)[as.character(unique(d1$labels))]
x <- x[y!=-Inf]
y <- y[y!=-Inf]
x
y
d1
opt2[,1:2]
runApp()
runApp()
runApp()
runApp()
opt2 <- read.csv(inFile$datapath)
opt2 <- read.csv("~/QE_49ST_10K_reduced.csv")
opt2[1:5,1:5]
mexp <- data.frame(suffix=c("pM", "nM", "uM"), fac=c(10^-12, 10^-9, 10^-6))
exp <- read.csv(inFile$datapath)
exp <- read.csv("~/43_ST_TSQ_table_feed_reducedMASSONLY.csv")
exp2 <- as.matrix(exp[, 1:2])
head(exp2)
exp2[1,1]
as.numeric(exp2[1,1])
runApp()
mn <- sub("_", "", opt2[,2])
mstep1 <- as.numeric(gsub("\\D", '', mn))
mstep2 <- mexp[sapply(gsub("\\d", '', mn), function(x) which(mexp[,1]==x)),2]
vec <- order(mstep1 * mstep2)
summ <- rep("", 5)
for(j in 3:ncol(opt2)) {
d1 <- data.frame(x=1:nrow(opt2), int=as.vector(as.matrix(log10(as.numeric(opt2[,j])))), labels=mn)
d1 <- d1[vec,]
x <- 1:length(unique(d1$labels))
y <- tapply(d1$int, d1$labels, mean)[as.character(unique(d1$labels))]
x <- x[y!=-Inf]
y <- y[y!=-Inf]
if(length(y)>1) {
s1 <- summary((lm(y~x)))
# added one regression parameter, the slope at the end
summ <- rbind(summ, c(j, colnames(opt2)[j] ,  round(s1$adj.r.squared, 3), s1$coefficients[2,4], s1$
coefficients[,1][2]) )
} else{
summ <- rbind(summ, c(j, colnames(opt2)[j],  0, 0, 0))
}
}
#trresults_all <- summ
summ <- summ[-1,][!is.nan(as.numeric(summ[-1,3])),]
selsumm <- summ[as.numeric(as.matrix(summ[,3]))>0,]
name2fet <- function(fet) {
strf <- strsplit(fet, "\\.")
mz <- paste(strf[[1]][1:2], collapse = ".")
mz <- as.numeric(sub("^X", "", mz))
rt <- as.numeric(paste(strf[[1]][3], collapse = "."))
c(mz, rt)
}
fetm <- as.vector(as.matrix(selsumm[,2]))
fetm <- do.call(rbind, lapply(fetm, name2fet))
m.list.mz.rt_opt <- apply(exp2, 1,  function(x) which((fetm[,1] > as.numeric(x[1])-0.05) & (fetm[,1] < as.numeric(x[1])+0.05)))
m.list.mz.rt_opt[[1]]
selsumm <- cbind(selsumm, "")
for(i in 1:length(m.list.mz.rt_opt)) if(length(m.list.mz.rt_opt[[i]])) selsumm[m.list.mz.rt_opt[[i]], ncol(selsumm)] <- as.character(exp[i,2])
head(selsumm)
runApp()
runApp()
